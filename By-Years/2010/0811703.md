* 0811703
* CPA-CPL:   Addressing the Memory Bottleneck in High-Level Programming Systems
* CSE,CCF
* 09/01/2008,08/31/2010
* Arun Chauhan, Indiana University
* Standard Grant
* Almadena Chtchelkanova
* 08/31/2010
* USD 60,000.00

A combination of factors has resulted in an industry-wide move to build multiple
cores on a single chip to sustain the rate of growth in the computing power of
processors. At the same time, high-level programming systems (e.g., scripting
languages) have gained tremendous popularity motivated by dramatically higher
programming productivity that such systems afford compared to traditional
programming languages, such as C/C++ or Java. Unfortunately, these two trends
combine to increase the gap between application software and the underlying
hardware, which negatively impacts hardware utilization. An important reason is
the critical nature of memory subsystems on the modern multi-core processors and
a lack of any systematic methods to derive the memory behavior of programs
written in high-level programming systems. This research aims at addressing the
problem by developing a theoretical model to estimate the memory behavior of
programs written in MATLAB and implementing the model in a prototype
compiler.&lt;br/&gt;&lt;br/&gt;A quantitative metric that past researchers have
found useful in memory-related optimizations is reuse distance. Defined as the
volume of data accessed between two successive references to a memory location,
the goal is to transform programs to lower most of their reuse distances to
below a threshold (usually, related to cache size).&lt;br/&gt;By restricting the
computation of reuse distances to locations accessible at the source-level it is
possible to define source-level reuse distance. The metric, even though
approximate, enables crucial analysis for high-level programming systems that
often benefit remarkably from source-level transformations. This research
develops efficient algorithms for source-level reuse distance analysis,
validates it against the actual program behavior, and implements it in a MATLAB
compiler to drive memory-related optimizations, especially those related to
array accesses.&lt;br/&gt;
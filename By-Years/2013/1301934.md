* 1301934
* CSR: Medium: Collaborative Research: The Commutativity Rule for Scalable Systems Software
* CSE,CNS
* 10/01/2013,09/30/2016
* M. Frans Kaashoek, Massachusetts Institute of Technology
* Standard Grant
* Marilyn McClure
* 09/30/2016
* USD 299,995.00

After decades of reliable improvement, processor speeds
have&lt;br/&gt;flattened; for the foreseeable future, computers will add
processing&lt;br/&gt;power by adding more processors, rather than faster ones.
This is a&lt;br/&gt;tremendous challenge for software designers. It's far too
easy for&lt;br/&gt;software using multiple processors to burn up a growing
fraction of&lt;br/&gt;available processing power on coordination overheads like
locking,&lt;br/&gt;rather than actual work. That is, it's far too easy for
software to&lt;br/&gt;not scale: to get slower as processors are added. And an
important&lt;br/&gt;reason for this is simply that scalability is poorly
understood. Some&lt;br/&gt;programs don't scale because they're badly written,
but others don't&lt;br/&gt;scale because their goals are fundamentally
impossible to accomplish&lt;br/&gt;in a scalable way. Programmers lack effective
tools for high-level&lt;br/&gt;reasoning about software scalability limitations,
and thus waste&lt;br/&gt;effort on both impossible and uninteresting
tasks.&lt;br/&gt;&lt;br/&gt;We will produce the first well-grounded and formal
reasoning procedure&lt;br/&gt;for scalability that is flexible enough to apply
to an entire&lt;br/&gt;operating system. Our scalability rule links
commutativity and&lt;br/&gt;scalability. We characterize software interfaces as
more or less&lt;br/&gt;inherently scalable depending on the contexts in which
those&lt;br/&gt;interfaces commute: the more commutative an interface (that is,
the&lt;br/&gt;more often the order of its function calls doesn't matter), the
more&lt;br/&gt;scalable an implementation can be. We prove that a
scalable&lt;br/&gt;implementation exists for any commutative context. This idea
can&lt;br/&gt;already guide software designers in developing easily-
scalable&lt;br/&gt;interfaces, but we will also provide a set of automated tools
for&lt;br/&gt;measuring interface commutativity and for finding
implementation&lt;br/&gt;scalability bottlenecks, and evaluate our ideas in a
highly-scalable&lt;br/&gt;operating system. The resulting tools and ideas could
make scalable&lt;br/&gt;software far easier to design and program, and thus help
software&lt;br/&gt;designers provide the software performance on which so much
of our&lt;br/&gt;economy depends.